
# SENSITIVITY TESTS: DATA TREATMENT AND BENCHMARK CALCULATIONS

## Spawner-Recruit Data Filtering and Infilling {#AltSRTest}

### Purpose

We filtered out implausible spawner-recruit observations and infilled gaps to allow fitting model forms that require complete time series (Section \@ref(AvailableSRData)). We tested the effect of alternative data treatments on benchmark estimates from the basic Ricker model.

Infilling a few return years can drastically increase the number of brood years available for spawner-recruit analyses.  For example, if a single spawner estimate is missing from the time series, then recruits cannot be calculated for 3-6 earlier brood years, depending on the age composition for the stock. If there are several gaps, many brood years may have incomplete cohort information and can't be used in the analyses. 

### Methods

We applied two alternative data filter options and then either infilled or didn't infill 1-yr gaps in spawner estimates. Infilled spawner values were calculated as the average of previous and subsequent estimates, and then the corresponding run size was calculated using the year-specific exploitation rate estimate from the run reconstruction models. The infilled spawner and run size estimates were then used in the recruit calculation based on on available age composition data.

This generated six alternative versions of the spawner-recruit time series: 

* *Main*: original data set generated by the data review documented in @SkeenaNassSkDataRep
* *Filter1k*: exclude brood years where R/S > 1,000 
* *Filter45*: exclude brood years where R/S > 45
* *Main_Infill*: original data with infills where possible
* *Filter1k_Infill*: Filter1k data with infills where possible
* *Filter45_Infill*: Filter45 data with infills where possible

This sensitivity test applied the Basic Ricker model (Section \@ref(ModelForms)) with capped uniform capacity priors (Section \@ref(Priors)) to all stocks where any filtering or infilling occurred. The Basic Ricker model is the only one that can be applied to all stocks, because it does not require a continuous time series.

### Results


There were very few cases where a filtered year could be infilled afterwards (Table \@ref(tab:AltSRTestTab1)). The number of infilled return years and resulting additional brood year estimates varied between stocks. In some cases, a few infills allowed for many additional brood year estimates. For example, infilling spawner and run size estimates for Bear made it possible to complete recruit estimates for another 13 brood years (from 36 to 49 data points). 

Benchmark and parameter estimates were quite stable across data variations for some stocks (e.g., Bear, Johnston, Sustut, Kitsumkalum, Mcdonell), but very sensitive for others (e.g., Kwinageese, Swan/Stephens). 



### Conclusions

We chose to use the *Filter45_Infill* version of the data for the analyses presented in this Research Document, because it excluded several extreme outliers and it completed the time series for several stocks, allowing AR1 and TVP models to be applied.



(ref:AltSRTestTab1) Summary of Filtering and Infilling Test. For each data version, table lists the number of spawner-recruit data points (BrYr), the number of filtered years that were infilled and included (Filter), the number of years the were infilled (Infill), and the resulting % change in median posterior estimates of Ricker parameters and standard benchmarks. All SR model fits used the Bayesian Basic Ricker (BR) with capped uniform prior (cu), with the same MCMC settings (as described in Section \@ref(SRFitting)).

```{r AltSRTestTab1, echo = FALSE, results = "asis"}


table.in <- alt.sr.test1 %>% mutate_all(as.character) %>% select(-Model)

# https://stackoverflow.com/questions/36084147/index-of-the-first-occurence-of-each-value-in-a-vector
lines.idx <- which(!duplicated(table.in$Stock))[-1]  # drop first element


table.in[is.na(table.in)] <- ""
table.in$Stock[duplicated(table.in$Stock)] <- ""

col.names.use = c("Stock","Version","BrYr","Filter","Infill","beta","ln.alpha","Seq","Smsy","Sgen")



   
table.in %>% 
   mutate_all(function(x){gsub("&", "\\\\&", x)}) %>% 
	 mutate_all(function(x){gsub("_", "\\\\_", x)}) %>% 
   mutate_all(function(x){gsub("%", "\\\\%", x)}) %>%
   mutate_all(function(x){gsub("\\\\n","\n", x)}) %>%
#   mutate_all(function(x){gsub("\\\\#","\#", x)}) %>%
   csas_table(format = "latex", escape = FALSE, font_size = 10, align = c("l","l","l",rep("r",8)),
                  caption = "(ref:AltSRTestTab1)", col.names = col.names.use ) %>%
   add_header_above(c(" " = 1, "Data" = 4, "Change in median estimates (%)" = 5)) %>%
     kableExtra::row_spec(lines.idx -1, hline_after = TRUE) #%>%
     #kableExtra::column_spec(3, width = "10em") %>%
     #  kableExtra::row_spec(c(1:5,7:14,16:22), extra_latex_after = "\\cmidrule(l){2-8}") 

```


\clearpage
## Infilling with a Generic State-Space Model  {#StateSpaceTest}

### Purpose

The infilling approach and sensitivity test summarized in Section \@ref(AltSRTest) were debated at the peer review meeting in April 2022, and further sensitivity testing of the infill approach was requested. 

Rather than setting up a bootstrap test to evaluate sensitivity, we decided to test a Bayesian approach that has been commonly used for Alaskan and northern transboundary salmon escapement goal analyses: a  Bayesian state-space model that integrates the run reconstruction and spawner-recruit parameter estimation steps into a single model fit [e.g., @BernardJones2010AlsekCk; @HamazakietalKusko2012; @Fleischmanetal2013CJFASStateSpace; @FleischmanMcKinleyKenai2013; @MillerPestalTakuSk; @Connorsetal2022]. 

In this type of model we don't need to infill missing brood years up front to fit AR1 or TVP model forms, but instead the model searches for SR parameters *and* annual estimates of run reconstruction components (e.g., spawners, harvest, age composition) that *together* give the best fit. Any missing brood years are filled in as part of the Bayesian run reconstruction.

Previous applications have been highly case-specific in terms of the run reconstruction components and their prior distributions. For example:

*  @Fleischmanetal2013CJFASStateSpace modelled the Karluk River Chinook run based on a weir count in the lower river, three different fisheries below the weir (subsistence, recreational, commercial), and a recreational fishery above the weir. Observation errors were specified based on the estimate type: weir counts and commercial harvest estimates based on fish sales slips were considered precise, but recreational harvest  estimates based on mail-in surveys were considered more uncertain.
* @FleischmanMcKinleyKenai2013 modelled the late run of Kenai River Chinook using eight components covering various time periods and locations: multi-beam sonar, in-river test fishery, split-beam sonar,  lower river sport fishery, commercial set-net fishery, sonar echo-length, radio-telemetry capture-recapture estimates, and genetic capture-recapture estimates.
* @MillerPestalTakuSk modelled the Taku Sockeye run reconstruction based on three components: in-river mark-recapture estimates at the border, below-border harvests, and above border harvests.

This level of detail is prohibitive for our project covering 20 stocks in two aggregates. However, a generic version of an integrated run reconstruction and spawner-recruit model could be applied efficiently across multiple stocks while providing some flexibility for stock-specific considerations. Such a generic state-space model is being developed by Toshihide Hamazaki (ADF&G), who generously shared an [interactive online prototype](https://hamachan.shinyapps.io/Spawner_Recruit_Bayes/) implemented in Shiny-R. We refer to this tool as the *Hamazaki App* throughout the paper.

The Hamazaki App allows users to fit alternative SR models, explore standard probability profiles based on the SR parameters (e.g., probability of achieving at least 75% of MSY at different fixed escapement targets), and even generate simple forward simulations with different types of harvest strategy. The state-space option in the Hamazaki App implements the methods described in @HamazakietalKusko2012, but simplifies the run reconstruction to three components:  Harvest estimates, either escapement or run, and run age composition.  For each annual abundance observation, users can specify a level of uncertainty, expressed as a CV, and for run age composition a weight to be used, expressed as an effective sample size (*efn*). With a structure like this, users can capture changes in assessment approach over time (e.g., earlier data based on aerial surveys can be assigned a larger CV than more recent estimates from a capture-recapture program). Individual run age composition observations that are considered very poor can be down weighted by assigning higher CV (e.g., if the weir was washed out partway through the season and the estimate was expanded to account for it) or lower efn (e.g., if a year has fewer completed age readings).


### Methods

We used the Hamazaki App to test 10 alternative versions of SR model fit, covering three Ricker model forms (Basic, AR1, and TVP; Section \@ref(ModelForms)), two estimate types (regular, state-space), and two data sets (with or without infilling). Only the Basic Ricker model could be applied to data without infilling with the regular estimation approach, but in the state-space approach all three model forms could be applied.

We tested these alternatives on two stocks: Kwinageese, which has a shorter time series and four missing brood years, and Lakelse, which has a longer time series and two missing brood years (Figure \@ref(fig:SRDataOverview)). For both stocks, we assigned moderate uncertainty to the spawner and run data (CV = 0.2) and large effective sample size (efn = 100). The "no infill" version of the data for the state-space estimates used the infilled numbers in order to populate all the fields in the data file, but assigned much larger uncertainty (CV = 0.6) and a very low effective sample size (efn = 0), so that the state-space model puts very little weight on the infilled values in the estimation step. The "infill" version of the data for the state-space estimates used the infilled numbers and assigned a large effective sample size (efn = 100), so that the model treats the infilled values just like  observed values.

Note that results for the time-varying productivity model (TVP) are not directly comparable to our results. The Hamazaki App reports average parameter and benchmark estimates across all brood years as the default, and those estimates are reported here. However, in our analyses we subsampled from various time windows (Section \@ref(ModelSelection)) to generate alternative productivity scenarios (e.g., last 2 generations). The Hamazaki App also identifies shifts in productivity regimes and generates benchmark estimates for each regime, but we did not fully explore this feature, and do not report the results here.


### Results

For both stocks, Bayesian parameter estimates for all 10 alternative fits converged and generated median posterior estimates of biological benchmarks (Figure \@ref(fig:StateSpaceComp), Tables \@ref(tab:StateSpaceTab1) and \@ref(tab:StateSpaceTab2)). However, the sensitivity of estimates differed between stocks and varied between benchmarks: (1) Benchmark estimates were less sensitive than abundance estimates for individual brood years, (2) Smax and Seq estimates were more sensitive than Smsy estimates; (3) Lakelse estimates were more sensitive than Kwinageese estimates, even though Kwinageese has fewer brood years of SR data and has more missing years in the time series.

For all state-space model fits, the posterior distribution of spawner estimates was more uncertain (i.e., wider) with the "no infill" version of the data (with larger CV on the input values) and the median estimate differed depending on the SR model form (Figure \@ref(fig:StateSpaceComp)). The difference in posterior median abundance estimates was larger for Lakelse than for Kwinageese.

Median posterior benchmark estimates for Kwinageese are so similar across the 10 alternative fits that they are identical for practical purposes (Table \@ref(tab:StateSpaceTab1)). A more in-depth comparison may show differences in the shape of the posteriors (i.e., wider or narrower, more or less skewed), but this would require more thorough testing of the model settings (i.e., the CV and efn values) and the MCMC specifications (i.e., sample size, burn-in, thinning), which falls outside the scope of this example.

Median posterior benchmark estimates for Lakelse differ more between model forms and estimate types than between data versions with or without infilling (Table \@ref(tab:StateSpaceTab2)). State-space estimates are lower than the regular Bayesian estimates for all model forms and data versions.



### Conclusions

For the two stocks tested in this example, the effect of infilling depends more on stock-specific details (e.g., what the scatter of SR data points looks like, and where the infill values fall) and model fitting approach than the specific details of the infilling step itself. This result supports our current infilling approach for this round of work, and sets the stage for future work to more fully explore the strengths and limitations of applying generic state-space models across all 20 modelled Skeena and Nass Sockeye stocks. 



\clearpage

(ref:StateSpaceComp) State-space posterior estimates of spawner abundance for missing brood years. Each panel shows six alternative estimates of spawner abundance for a stock and brood year, comparing three SR model forms (Basic, AR1, TVP) and two alternative data sets (*Infill* = assign infilled values the same uncertainty and weight as observed values, *No Infill* = assign larger uncertainty and lower weight to infilled values). Top panels show two of four missing brood years for Kwinageese, bottom panels show both missing brood years for Lakelse.

```{r StateSpaceComp,  fig.cap="(ref:StateSpaceComp)" }
include_graphics("data/StateSpaceTest/StateSpace_EstimateComparison.png")
```



\clearpage
(ref:StateSpaceTab1) Kwinageese: Posterior median estimates of biological benchmarks for alternative model forms, estimate types, and data versions.

```{r StateSpaceTab1, echo = FALSE, results = "asis"}


table.in <- read.csv("data/StateSpaceTest/HamazakiAppOutputs_ReportTableSource.csv",stringsAsFactors = FALSE) %>% 
	dplyr::filter(Stock == "Kwinag") %>% select(-Stock)
							

table.in$ModelForm[duplicated(table.in$ModelForm)] <- ""

col.names.use = c("Model Form","Est Type","Data Version","Smsy","Smax","Seq")

table.in %>% 
   mutate_all(function(x){gsub("&", "\\\\&", x)}) %>% 
	 mutate_all(function(x){gsub("_", "\\\\_", x)}) %>% 
   mutate_all(function(x){gsub("%", "\\\\%", x)}) %>%
   mutate_all(function(x){gsub("\\\\n","\n", x)}) %>%
#   mutate_all(function(x){gsub("\\\\#","\#", x)}) %>%
   csas_table(format = "latex", escape = FALSE, font_size = 10, align = c("l","l","l",rep("r",3)),
                  caption = "(ref:StateSpaceTab1)", col.names = col.names.use ) %>%
     kableExtra::row_spec(c(4,7), hline_after = TRUE) %>%
    kableExtra::row_spec(c(2,5,8), extra_latex_after = "\\cmidrule(l){2-6}") 

```



(ref:StateSpaceTab2) Lakelse: Posterior median estimates of biological benchmarks for alternative model forms, estimate types, and data versions.  

```{r StateSpaceTab2, echo = FALSE, results = "asis"}


table.in <- read.csv("data/StateSpaceTest/HamazakiAppOutputs_ReportTableSource.csv",stringsAsFactors = FALSE) %>% 
	dplyr::filter(Stock == "Lakelse") %>% select(-Stock)
							

table.in$ModelForm[duplicated(table.in$ModelForm)] <- ""

col.names.use = c("Model Form","Est Type","Data Version","Smsy","Smax","Seq")

table.in %>% 
   mutate_all(function(x){gsub("&", "\\\\&", x)}) %>% 
	 mutate_all(function(x){gsub("_", "\\\\_", x)}) %>% 
   mutate_all(function(x){gsub("%", "\\\\%", x)}) %>%
   mutate_all(function(x){gsub("\\\\n","\n", x)}) %>%
#   mutate_all(function(x){gsub("\\\\#","\#", x)}) %>%
   csas_table(format = "latex", escape = FALSE, font_size = 10, align = c("l","l","l",rep("r",3)),
                  caption = "(ref:StateSpaceTab2)", col.names = col.names.use ) %>%
     kableExtra::row_spec(c(4,7), hline_after = TRUE) %>%
    kableExtra::row_spec(c(2,5,8), extra_latex_after = "\\cmidrule(l){2-6}") 

```





